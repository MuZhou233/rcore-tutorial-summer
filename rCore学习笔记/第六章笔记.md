这一章相对于前两章简单了许多，实现了进程间管道和邮箱的功能。

```
.
└── os
    └── src
        ├── fs
        │   ├── mail.rs
        │   ├── mod.rs
        │   ├── pipe.rs
        │   └── stdio.rs
        ├── mm
        │   └── page_table.rs
        ├── syscall
        │   ├── fs.rs
        │   └── mod.rs
        └── task
            └── task.rs
```

## 文件描述符

`os/src/fs`模块遵循Unix一切皆文件的原则抽象出了文件的概念即`File trait`，它的特点是可读可写可传递。  
目前实现了`File trait`的有：

- `Stdin` 和 `Stdout` 从第二章开始就已经存在，但之前只是一个常量，现在实现了文件接口。它们的本质是sbi实现的串口。
- `Pipe` 后面再说

虽然已经有很多个实现了，但是这些实现中没有真正的文件（因为还没有文件系统）。但它们的读写接口和真正的文件是一样的。  
`os/src/mm/page_table.rs`实现了`File trait`两个函数的参数类型，这是因为内存空间的问题，之前mm模块中的 `translated_byte_buffer` 方法可以返回应用传递的一段内存在内核内存空间中的位置，`UserBuffer` 将该方法返回的二维向量封装成一个迭代器方便使用。  

为了方便管理内核为已经打开的文件分配编号也就是文件描述符，比如在Unix中0为标准输入1为标准输出2为标准错误输出。  
在进程控制块中增加了一项用于保存文件描述符的线性表，文件描述符依旧通过结构体封装控制其分配和回收，这样就实现了对进程的文件操作的控制。

## 管道

这一章实现的管道对于进程来说就像一个小的临时文件，只能通过系统调用来创建，进程只能持有管道的只读或只写描述符。  
对于内核来说管道就是内核堆中的一个循环队列，由持有管道描述符的进程实例共同通过`Arc`持有。  
`os/src/fs/pipe.rs`实现了管道

## 邮件

因为本章内容不多但编程练习相对来说复杂了一些所以也写在笔记里。  

乍一看邮件功能实现起来和管道差别不大，不同点在于：

1. 邮件以报文为单位而不是管道的以字节为单位
2. 进程可以将邮件发送给任意进程而不受描述符的限制

第一个问题只要修改结构体内部的代码就可以实现，第二个问题要复杂一些。  
要实现发件不受限制就有几个解决方法：  
一个方法是让所有进程都持有所有进程的邮件描述符，这很明显不是个好办法。  
还有一个方法是在发件时内核查找到对应进程的实例并操作邮箱，这个方法的问题在于进程在运行时实例由处理器内核持有，等待时由进程管理器持有，查找起来既不方便也容易出错。  
所以我最后的解决方法是在内核中单独的线性表保存各进程的邮箱实例，这样只要通过pid查表即可找到该进程的邮箱实例。