# 实验一：中断

本实验的代码是在第一章的基础上合并产生的。

## 原理：在 rust_main 函数中，执行 ebreak 命令后至函数结束前，sp 寄存器的值是怎样变化的？

在执行 ebrak 命令后会立即进入`interrupt.asm`中的`__interrupt`，在该段程序中将sp减去了一个Context的大小，原来的值被保存。经过`handle_interrupt`的函数调用过程伴随着出入栈操作，在函数返回后sp被恢复为原来的值。

## 分析：如果去掉 rust_main 后的 panic 会发生什么，为什么？

原实验代码的`rust_main`函数并没有显式返回值即返回值是`()`，这会导致返回到调用main函数的汇编代码，但汇编中后面没有任何指令，导致程序跑飞。  
而在新的实验指导书中`rust_main`函数声明为`!`返回值即永远不会返回，这就避免了上面的问题，我们只能选择在函数最后退出、panic或死循环，否则无法通过编译。

## 实验

前两个实验比较简单，第三个对于不允许使用或修改unsafe块的要求和给出的解法有点取巧的感觉，而且在我合并出的版本上都无法顺利触发LoadFault异常，所以我最后还是选择了unsafe代码