这一章实现了简单的进程抽象和基础的系统调用

```
.
└── os
    ├── build.rs
    └── src
        ├── loader.rs
        ├── main.rs
        ├── mm/
        ├── sbi.rs
        ├── syscall
        │   ├── fs.rs
        │   ├── mod.rs
        │   └── process.rs
        ├── task
        │   ├── manager.rs
        │   ├── mod.rs
        │   ├── pid.rs
        │   ├── processor.rs
        │   └── task.rs
        └── trap
            └── mod.rs
```

## 进程的优势

相对于前面几章全部加载轮换执行的任务，进程是一个更加灵活和抽象的概念。现在我们可以称内核通过 `link_app.S` 插入的应用为可执行文件，而进程可以说是可执行文件的实例。与之前的任务最大的不同就是进程并不一定要在内核初始化完成后就创建，同一个可执行文件也可以创建不止一个进程。内核也不再以可执行文件的序号管理任务而是使用进程号，进程之间也有了从属关系。  
在本章终于实现了一个简单的shell（因为进程不一定在内核初始化完成后创建），也让应用有了并发的能力（同一个可执行文件可以创建多个进程）。

## 进程的抽象

`os/src/task/pid.rs` 文件实现了一个与上一章页帧管理器非常相似的进程号管理器，同样通过封装实现了进程号的抽象。由于内核现在按照进程号管理进程，所以预定义的内核栈也根据进程号分配给进程，所以现在 `KernelStack` 只需要保存进程号一个数据，所以也放在了这个文件中。
`os/src/task/task.rs` 文件中的 `TaskControlBlock` 现在是进程的抽象了，而且不像之前都放在 `TaskManager` 的数组中，现在这个结构体的实例会在函数之间传递。  
`os/src/task/processor.rs` 文件是处理器核心的抽象，其中包含的切换进程和获得进程信息的方法与前面章节任务管理器的一些方法非常相似，不同的是其中每一个 `Processor` 结构体的实例都会由一个处理器核心独占访问，并且会持有当前进程的实例所有权。

## fork + exec = spawn ?

几个系统调用是本章中比较难的部分：
`sys_fork` 要求复制出一个和当前进程完全相同的进程，然后给两个进程不同的返回值使同一个可执行文件表现出两个完全不同的逻辑。在实现的时候主要是解决内存空间的复制和新进程的堆栈。其他模块中增加的很多方法就是为了支持这一需要，内存空间的复制由 `MemorySet::from_existed_user()` 实现，该函数创建一个新的内存空间实例并从参数实例中逐个复制数据；`trap::trap_return()` 则提供了新进程的入口，该方法会正确地从新进程的内核态返回用户态。  
`sys_exec` 要求加载一个新的可执行文件到当前进程，在当前的实现中由于进程在运行时无法增加新的内存空间映射所以内核的处理方式就是直接释放原有的 `MemorySet` 并通过elf生成一个全新的。另一个要做的事情就是维护好trap代码段，在trap返回时会返回到elf文件指定的入口地址。  
`sys_spawn` 在本章的含义就是实现 `sys_fork` 和 `sys_exec` 连续调用的效果，而在内核的实现上最大的区别就是少了复制内存空间这一耗时的步骤。