这一章的主要内容是增加批处理应用程序的功能，增加的文件如下。这一章的实验指导并没有一步一步地介绍代码，所以很多新增代码是直接从示例中复制来再修改的。

```
.
├── os
│   ├── build.rs
│   ├── Cargo.toml
│   ├── Makefile
│   └── src
│       ├── batch.rs
│       ├── link_app.S
│       ├── main.rs
│       ├── syscall
│       │   ├── fs.rs
│       │   ├── mod.rs
│       │   └── process.rs
│       └── trap
│           ├── context.rs
│           ├── mod.rs
│           └── trap.S
└── user
    ├── Cargo.toml
    ├── Makefile
    └── src
        ├── bin
        │   ├── 00hello_world.rs
        │   ├── 01store_fault.rs
        │   ├── 02power.rs
        │   ├── 03priv_intr.rs
        │   └── 04priv_csr.rs
        ├── console.rs
        ├── lang_items.rs
        ├── lib.rs
        ├── linker.ld
        └── syscall.rs
```

## 应用程序

这一章实现应用程序的方式比较粗暴，由于还没有文件系统之类的加载方式，所以在编译的时候将应用程序的数量和地址存入系统然后逐个加载执行

`user`文件夹的内容和os非常相似，不同点主要是：
- `linker.ld`中起始地址是`0x80400000`
- `syscall.rs`虽然同样是通过`ecall`实现了提权，但在本章中会由os处理
- `user/src/bin`文件夹中是各个简单的应用程序代码
- `lib.rs`中通过`#[linkage = "weak"]`实现了默认的main函数防止在应用程序没有main函数时通过编译并出现运行时错误

## 链接应用程序

> 一些包需要编译第三方非 Rust 代码，例如 C 库。其他的包需要链接到 C 库，当然这些库既可以位于系统上，也可以从源代码构建。其他人或许还需要功能工具，比如构建之前的代码生成 (想想解析生成器)。`FROM: The Cargo Book`

实现链接应用程序和系统的核心是Cargo Build Script，默认文件名为`build.rs`的编译脚本会在编译其他内容之前被编译执行。我们的编译脚本的工作就是读取已经编译好的二进制应用程序并且生成一个包含应用数量、必要的地址标号和二进制文件路径的`link_app.S`文件，这样系统就可以通过引入该文件将应用程序包含在编译得到的二进制文件中。

### 增加对测例的支持

第二章的练习部分提到了另一个包含各章节测例的仓库，测例仓库虽然已经有了完善的生成脚本，但rcore这边的Makefile并没有相应的支持，所以我修改了编译脚本实现了对测例仓库的支持。

首先了解一下原来的编译脚本的内容：
- `main`函数中打印了两行格式比较奇怪的字符串之后调用了`insert_app_data`函数，那两行格式比较奇怪的字符串会在输出后被cargo解析，含义是若该路径有内容被修改则重新运行脚本。
- `insert_app_data`函数读取硬编码的`../user/src/bin`目录的文件，生成`link_app.S`文件。并且这个函数不会检查文件名，实验指导书中所说的按数字大小顺序装载应用程序也只是因为那个是默认排序

所以修改方式也不难，只要将几个硬编码的路径改为接受外部输入即可。我的实现方式是在`Makefile`中定义几个路径的环境变量，在`build.rs`中读取。

## 应用程序管理器

`batch.rs`定义了应用程序管理器，首先回答实验指导书中的问题，结构体使用RefCell和Sync是受到并发安全的限制，在单线程时不会有问题，static mut的访问是unsafe是因为有数据竞争风险，Sync标记标识该结构体能够安全地在线程间传递。  
管理器的初始化需要读取`link_app.S`中标记的地址，而具体的地址在编译时是无法确定的，所以使用`lazy_static`宏实现了运行时初始化。初始化的内容是读取`_num_app`标记的地址，该地址按顺序记录了应用的数量、各个应用的入口和最后一个应用的结尾地址，将这些内容存入结构体以便之后使用。  
装载应用程序的过程也比较简单，应用程序运行时所在的位置是硬编码的从`0x80400000`开始的一段地址（这对应了`user/src/linker.ld`中的地址）。在装载前先清空运行应用程序的地址段和指令缓存，然后将程序复制到该地址并跳转到该地址执行

## 特权级转换

这部分我认为是本章最难理解的部分，一方面是因为涉及到了riscv特权级切换时各个寄存器的细节，另一方面*不安全*的代码占比也更大，核心的切换逻辑直接使用汇编实现。

先从最简单的`os/src/syscall`开始，这部分乍一看和用户库的syscall差不多，但仔细看write和exit的实现，在用户库的syscall中这两个功能都通过ecall来到了系统库的syscall模块，系统中的write函数调用之前实现的print!宏打印了请求的内容（print!宏是怎么实现的？是通过sbicall实现的），exit函数直接调用应用程序管理器切换应用了。  
编程练习中要求实现的地址检查也并不难，应用程序能够访问的地址段一共有两个，一个是应用程序自己所在的地址段，另一个就是应用栈，所以write函数在写之前检查请求的地址是否在这两段之中就可以了。

Trap管理部分，`trap.S`中两段代码分别实现了应用程序上下文保存与恢复的逻辑，在初始化时将保存的代码地址存入`stvec`寄存器，这是实现从应用程序切换到系统的重点，在应用程序执行ecall或其他非法指令时（被委托的部分）硬件就会跳转到`stvec`寄存器的地址（相应的，M模式的Trap处理地址寄存器叫做`mtvec`）。另一个我认为非常重要的就是sp指针的处理，`batch.rs`中定义了内核栈和用户栈两个栈，两个栈的切换是在`trap.S`的上下文切换中进行的，一个栈顶存在sp另一个栈顶存在`sscratch`寄存器，切换栈即交换两个寄存器的值  