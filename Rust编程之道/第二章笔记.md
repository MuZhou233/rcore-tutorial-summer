### 语句与表达式

Rust 中的语法可以分成两大类：语句（Statement）和表达式（Expression）  
Rust 编译器在解析代码的时候，如果碰到分号，就会继续往后面执行；如果碰到语句，则执行语句；如果碰到表达式，则会对表达式求值，**如果分号后面什么都没有，就会补上单元值()**；当遇到函数的时候，会将函数体的花括号识别为块表达式（Block Expression）。
块表达式是由一对花括号和一系列表达式组成的，**它总是返回块中最后一个表达式的值**。

### 变量与绑定

通过let关键字来创建变量，let创建的变量一般称为绑定（Binding）*理解为将标识符与值绑定，而非创建标识符并赋值*

### 位置表达式与值表达式

表达式一般可以分为位置表达式（ Place Expression）和值表达式（ ValueExpression）。在其他语言中，一般叫作左值（LValue）和右值（RValue）。顾名思义，位置表达式就是表示内存位置的表达式。通过位置表达式可以对某个数据单元的内存进行读写。**主要是进行写操作**，这也是位置表达式可以被赋值的原因。除此之外的表达式就是值表达式。值表达式一般只引用了某个存储单元地址中的数据。它相当于数据值，**只能进行读操作**。  
**从语义角度来说，位置表达式代表了持久性数据，值表达式代表了临时数据。**

### 所有权与引用

当位置表达式出现在赋值操作符右侧，即一个值上下文中时会发生所有权转移  
在语义上，每个**变量绑定实际上都拥有该存储单元的所有权**，这种转移内存地址的行为就是所有权（OwnerShip）的转移，在 Rust 中称为移动（Move）语义，那种不转移的情况实际上是一种复制（Copy）语义。

### 作用域与生命周期

Rust 语言的作用域是静态作用域，即词法作用域（Lexical Scope）。由一对花括号来开辟作用域，其作用域在词法分析阶段就已经确定了，不会动态改变。词法作用域。连续用 let定义同名变量的做法叫变量遮蔽（Variable Shadow）。*叫做遮蔽的原因是如果内层作用域遮蔽了一个外层标识符，则后面对该标识符的操作不会影响外层，从内层作用域退出后仍可访问遮蔽前的标识符及其值*  
这证明，在词法作用域内部使用花括号开辟新的词法作用域后，两个作用域是相互独立的。在不同的词法作用域内声明的变量绑定，拥有不同的生命周期（LifeTime）。尽管如此，变量绑定的生命周期总是遵循这样的规律：**从使用 let 声明创建变量绑定开始，到超出词法作用域的范围时结束。**

### CTFE机制

Rust编译器也可以像C++或D语言那样，拥有编译时函数执行（Compile-Time FunctionExecution，CTFE）的能力。Rust中的CTFE是由miri来执行的。miri是一个MIR解释器

### 闭包

闭包也叫匿名函数。闭包有以下几个特点：可以像函数一样被调用；可以捕获上下文环境中的自由变量；可以自动推断输入和返回的类型。  
**闭包和函数有一个重要的区别，那就是闭包可以捕获外部变量，而函数不可以。Rust中闭包实际上就是由一个匿名结构体和trait来组合实现的。**  
在一般情况下，闭包默认会按引用捕获变量。如果将此闭包返回，则引用也会跟着返回。使用move关键字，将捕获变量的所有权转移到闭包中，就不会按引用进行捕获变量

### 流程控制

一般编程语言都会有常用的流程控制语句：条件语句和循环语句，Rust也不例外。但是在Rust中不叫流程控制语句，而叫流程控制表达式。*流程控制表达式表明这些流程控制块有值*  

### match

在Rust语言中，match分支左边就是模式，右边就是执行代码。模式匹配同时也是一个表达式，和if表达式类似，所有分支必须返回同一个类型。但是左侧的模式可以是不同的。使用操作符@可以将模式中的值绑定给一个变量，供分支右侧的代码使用，这类匹配叫绑定模式（BindingMode）。match表达式必须穷尽每一种可能，所以一般情况下，会使用通配符_来处理剩余的情况。

### 泛型和trait

泛型和trait是Rust类型系统中最重要的两个概念。  
泛型并不是Rust特有的概念，在很多强类型编程语言中也支持泛型。泛型允许开发者编写一些在使用时才指定类型的代码。泛型，顾名思义，就是泛指的类型。  
trait同样也不是Rust独有的概念，它借鉴了Haskell的Typeclass。第1章已经介绍过，trait是Rust实现零成本抽象的基石，它有如下机制：**trait是Rust唯一的接口抽象方式**；可以静态生成，也可以动态调用；可以当作标记类型拥有某些特定行为的“标签”来使用。简单来说，trait是对类型行为的抽象。  
Rust通过trait将类型和行为明确地进行了区分，充分贯彻了**组合优于继承**和**面向接口编程**的编程思想。