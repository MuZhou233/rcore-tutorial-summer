### 零大小类型

Rust支持零大小类型（Zero Sized Type，ZST），比如单元类型和单元结构体，大小都是零。单元类型和单元结构体大小为零，由单元类型组成的数组大小也为零。ZST类型的特点是，它们的值就是其本身，运行时并不占用内存空间。ZST类型代表的意义正是“空”。
```rust
enum Void{}
struct Foo;
struct Baz {
    foo: Foo,
    qux: (),
    baz: [u8; 0],
}
```

### 底类型

底类型（Bottom Type）是源自类型理论的术语，它其实是第2章介绍过的never类型。它的特点是：没有值；是其他任意类型的子类型。如果说ZST类型表示“空”的话，那么底类型就表示“无”。底类型无值，而且它可以等价于任意类型，有点无中生有之意。  
Rust中的底类型用叹号（！）表示。此类型也被称为Bang Type。Rust中有很多种情况确实没有值，但为了类型安全，必须把这些情况纳入类型系统进行统一处理。这些情况包括：
- 发散函数（Diverging Function）。指会导致线程恐慌，或者用于退出的`std::process::exit`，这类函数永远都不会有返回值。
- continue和break关键字。只是表示流程的跳转，并不会返回什么。
- loop循环。loop循环虽然可以返回某个值，但也有需要无限循环的时候。
- 空枚举，比如`enum Void{}`完全没有任何成员，因而无法对其进行变量绑定，不知道如何初始化并使用它。

### Turbofish操作符

使用类似`parse::<i32>()`这样的形式为泛型函数标注类型，避免了变量声明。很多时候并不需要声明太多变量，代码看上去也能更加紧凑。这种标注类型`::<>`的形式就叫作turbofish操作符。

### 泛型

Rust中的泛型属于静多态，它是一种编译期多态。在编译期，不管是泛型枚举，还是泛型函数和泛型结构体，**都会被单态化**（Monomorphization）。单态化是编译器进行静态分发的一种策略。单态化意味着编译器要将一个泛型函数生成两个具体类型对应的函数。单态化静态分发的好处是性能好，没有运行时开销；缺点是容易造成编译后生成的二进制文件膨胀。

### trait

trait是在行为上对类型的约束，这种约束可以让trait有如下4种用法：

- 接口抽象。接口是对类型行为的统一约束。
- 泛型约束。泛型的行为被trait限定在更有限的范围内。
- 抽象类型。在运行时作为一种间接的抽象类型去使用，动态地分发给具体的类型。
- 标签trait。对类型的约束，可以直接作为一种“标签”使用。

#### 接口抽象

接口中可以定义方法，并支持默认实现；接口中不能实现另一个接口，但是接口之间可以继承；同一个接口可以同时被多个类型实现，但不能被同一个类型实现多次。  

**孤儿规则**（Orphan Rule）。孤儿规则规定，如果要实现某个trait，那么该trait和要实现该trait的那个类型至少有一个要在当前crate中定义。  

trait继承可以用于扩展标准库中的方法。

#### 泛型约束

使用trait对泛型进行约束，叫作trait限定（trait Bound）。格式如`fn generic<T: MyTrait + MyOtherTrait + SomeStandardTrait>(t: Ｔ){}`该泛型函数签名要表达的意思是：需要一个类型 T，并且该类型 T 必须实现 MyTrait、MyOtherTrait和SomeStandardTrait中定义的全部方法，才能使用该泛型函数。  
trait限定的思想与Java中的泛型限定、Ruby和Python中的Duck Typing、Golang中的StructuralTyping、Elixir和Clojure中的Protocol都很相似。所以有编写这些编程语言经验的开发者看到trait限定会觉得很熟悉。在类型理论中，Structural Typing是一种根据结构来判断类型是否等价的理论，翻译过来为结构化类型。Duck Typing、Protocol都是Structural Typing的变种，一般用于动态语言，在运行时检测类型是否等价。Rust中的trait限定也是Structural Typing的一种实现，可以看作一种静态Duck Typing。  
Rust编程的哲学是组合优于继承，Rust并不提供类型层面上的继承，Rust中所有的类型都是独立存在的，所以Rust中的类型可以看作语言允许的最小集合，不能再包含其他子集。而trait限定可以对这些类型集合进行组合，也就是求交集。

#### 抽象类型

trait还可以用作抽象类型（Abstract Type）。抽象类型属于类型系统的一种，也叫作存在类型（Existential Type）。相对于具体类型而言，抽象类型无法直接实例化，它的每个实例都是具体类型的实例。对于抽象类型而言，编译器可能无法确定其确切的功能和所占的空间大小。所以 Rust目前有两种方法来处理抽象类型：trait对象和impl Trait。  
trait本身也是一种类型，但它的类型大小在编译期是无法确定的，所以trait对象必须使用指针。可以利用引用操作符&或`Box<T>`来制造一个trait对象。trait对象除了包含指向数据的指针，还有一个包含析构函数、大小、对齐和方法等信息的虚表 （Virtual Table）。运行时会根据虚表指针从虚表中查出正确的指针，然后再进行动态调用。这也是将trait对象称为动态分发的原因。

并不是每个trait都可以作为trait对象被使用，这依旧和类型大小是否确定有关系。每个trait都包含一个隐式的类型参数Self，代表实现该trait的类型。Self默认有一个隐式的trait限定`?Sized`，形如`<Self: ?Sized>`，？Sized trait 包括了所有的动态大小类型和所有可确定大小的类型。Rust中大部分类型都默认是可确定大小的类型，也就是`<T: Sized>`，这也是泛型代码可以正常编译的原因。  
当trait对象在运行期进行动态分发时，也必须确定大小，否则无法为其正确分配内存空间。所以必须同时满足以下两条规则的trait才可以作为trait对象使用：trait的Self类型参数不能被限定为Sized；trait中所有的方法都必须是**对象安全**的。

对象安全的方法必须满足以下三点之一：
- 方法受Self：Sized约束。
- 方法签名同时满足以下三点。
    - 必须不包含任何泛型参数。如果包含泛型，trait对象在虚表（Vtable）中查找方法时将不确定该调用哪个方法。
    - 第一个参数必须为 Self 类型或可以解引用为 Self 的类型（也就是说，必须有接收者，比如self、&self、&mut self和self：Box＜Self＞，没有接收者的方法对trait对象来说毫无意义）。
    - Self不能出现在除第一个参数之外的地方，包括返回值中。这是因为如果出现Self，那就意味着Self和self、&self或&mut self的类型相匹配。但是对于trait对象来说，根本无法做到保证类型匹配，因此，这种情况下的方法是对象不安全的。
  这三点可以总结为一句话：没有额外Self类型参数的非泛型成员方法。
- trait中不能包含关联常量（Associated Constant）。在Rust 2018版本中，trait中可以增加默认的关联常量，其定义方法和关联类型差不多，只不过需要使用const关键字。

#### 标签trait

Rust一共提供了5个重要的标签trait，都被定义在标准库std::marker模块中。它们分别是：

- Sized trait，用来标识编译期可确定大小的类型。
- Unsize trait，目前该trait为实验特性，用于标识动态大小类型（DST）。
- Copy trait，用来标识可以按位复制其值的类型。
- Send trait，用来标识可以跨线程安全通信的类型。
- Sync trait，用来标识可以在线程间安全共享引用的类型。

除此之外，Rust标准库还在增加新的标签trait以满足变化的需求。

### 类型转换

**Rust中的隐式类型转换基本上只有自动解引用。**自动解引用的目的主要是方便开发者使用智能指针。Rust 中提供的 Box＜T＞、Rc＜T＞和 String 等类型，实际上是一种智能指针。它们的行为就像指针一样，可以通过“解引用”操作符进行解引用，来获取其内部的值进行操作。  
**自动解引用虽然是编译器来做的，但是自动解引用的行为可以由开发者来定义。**一般来说，引用使用&操作符，而解引用使用*操作符。可以通过实现Deref trait来自定义解引用操作。Deref 有一个特性是强制隐式转换，规则是这样的：如果一个类型 T实现了Deref＜Target=U＞，则该类型T的引用（或智能指针）在应用的时候会被自动转换为类型U。

当某类型和其解引用目标类型中包含了相同的方法时，编译器就不知道该用哪一个了。此时就需要手动解引用  
关于手动解引用： [Rust 概念解惑 | Deref vs AsRef vs Borrow vs Cow](https://mp.weixin.qq.com/s/OdcLb5U8QCeYH08feThN7w)

#### as 操作符

- 最常用的场景就是转换 Rust 中的基本数据类型，长类型转换为短类型会被**截断处理**  
- 为结构体实现多个trait时，可能会出现同名的方法，使用as操作符，`<S as A>::test()`或`<S as B>::test()`可以避免歧义
- as转换还可以用于类型和子类型之间的转换。Rust中没有标准定义中的子类型，比如结构体继承之类，但是**生命周期标记可看作子类型**。比如&＇static str类型是&＇a str类型的子类型，因为二者的生命周期标记不同，＇a 和＇static 都是生命周期标记，其中＇a 是泛型标记，是&str的通用形式，而＇static则是特指静态生命周期的&str字符串。所以，通过as操作符转换可以将&＇static str类型转为&＇a str类型

### trait 系统的不足

孤儿规则虽然在一定程度上保持了trait的一致性，但是它还有一些局限性。在设计trait时，还需要考虑是否会影响下游的使用者。比如在标准库实现一些trait时，还需要考虑是否需要为所有的T或&＇a T实现该trait，对于下游的子crate来说，如果想要避免孤儿规则的影响，还必须使用NewType模式或者其他方式将远程类型包装为本地类型。这就带来了很多不便。  
另外，对于一些本地类型，如果将其放到一些容器中，比如Rc＜T＞或Option＜T＞，那么这些本地类型就会变成远程类型，因为这些容器类型都是在标准库中定义的，而非本地。  
在标准库中给Box、Fn、FnMut、FnOnce、Sized等都加上了`＃[fundamental]`属性，代表这些trait不受孤儿规则的限制。***未稳定***

重叠（Overlap）规则。该规则规定了不能为重叠的类型实现同一个trait。重叠规则和孤儿规则一样，都是为了保证trait一致性，避免发生混乱，但是它也带来了一些问题，主要包括两个方面：性能问题；代码很难重用。为了缓解重叠规则带来的问题，Rust 引入了特化（Specialization）***未稳定***

迭代器在Rust中应用广泛，但是它目前有一个**缺陷：在迭代元素的时候，只能按值进行迭代，有的时候必须重新分配数据，而不能通过引用来复用原始的数据。**  
这是因为迭代器的实现基于关联类型，而关联类型目前只能支持具体的类型，而不能支持泛型。不能支持泛型就导致无法支持引用类型，因为Rust里规定使用引用类型必须标明生命周期参数，而生命周期参数恰恰是一种泛型类型参数。  
为了解决这个问题，就必须允许迭代器支持引用类型。只有支持引用类型，才可以重用内部缓存区，而不需要重新分配新的内存。所以，就必须实现一种更高级别的类型多态性，即泛型关联类型（Generic Associated Type，GAT）***未稳定***